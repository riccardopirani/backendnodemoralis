
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";

contract JetCVNFT is ERC721URIStorage {
    // Mappa utente => tokenId NFT (JetCV)
    mapping(address => uint256) public userCVTokenId;
    uint256 public nextTokenId = 1;

    // Struttura certificazione
    struct Certification {
        address legalEntity;
        address certifier;
        string detailsURI;
        uint256 timestamp;
    }
    struct CertificationDraft {
        address legalEntity;
        address certifier;
        string detailsURI;
    }

    mapping(uint256 => CertificationDraft[]) public pendingCertifications;
    mapping(uint256 => Certification[]) public certifications;

    event CVMinted(address indexed user, uint256 indexed tokenId, string uri);
    event CertificationDrafted(uint256 indexed tokenId, address indexed legalEntity, address indexed certifier, string detailsURI);
    event CertificationApproved(uint256 indexed tokenId, address indexed legalEntity, address indexed certifier, string detailsURI, uint256 timestamp);
    event CertificationRejected(uint256 indexed tokenId, address indexed legalEntity, address indexed certifier, string reason);
    event CVUpdated(uint256 indexed tokenId, string newURI, address updater);

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}

    // Chiunque può mintare il proprio CV (ma solo uno per address)
    function mintCV(string memory uri) external returns (uint256) {
        require(userCVTokenId[msg.sender] == 0, "Hai gia' un CV NFT");
        uint256 tokenId = nextTokenId++;
        _safeMint(msg.sender, tokenId);
        _setTokenURI(tokenId, uri);
        userCVTokenId[msg.sender] = tokenId;
        emit CVMinted(msg.sender, tokenId, uri);
        return tokenId;
    }

    // Funzione esistenza tokenId
    function exists(uint256 tokenId) public view returns (bool) {
        try this.ownerOf(tokenId) returns (address) {
            return true;
        } catch {
            return false;
        }
    }

    // --- Certificazioni, identiche all'originale ---
    function proposeCertification(uint256 tokenId, string memory detailsURI) external {
        // Qui puoi inserire eventuali logiche di abilitazione per legal entity/certifier
        require(exists(tokenId), "CV inesistente");
        // Esempio: solo il proprietario può proporre, altrimenti togli questa riga
        // require(ownerOf(tokenId) == msg.sender, "Solo il proprietario puo' proporre");
        pendingCertifications[tokenId].push(CertificationDraft(msg.sender, msg.sender, detailsURI));
        emit CertificationDrafted(tokenId, msg.sender, msg.sender, detailsURI);
    }

    function approveCertification(uint256 tokenId, uint256 draftIndex) external {
        require(ownerOf(tokenId) == msg.sender, "Solo il proprietario puo' approvare");
        require(draftIndex < pendingCertifications[tokenId].length, "Indice bozza non valido");
        CertificationDraft memory draft = pendingCertifications[tokenId][draftIndex];
        certifications[tokenId].push(Certification(draft.legalEntity, draft.certifier, draft.detailsURI, block.timestamp));
        emit CertificationApproved(tokenId, draft.legalEntity, draft.certifier, draft.detailsURI, block.timestamp);
        _removeDraft(tokenId, draftIndex);
    }

    function rejectCertification(uint256 tokenId, uint256 draftIndex, string memory reason) external {
        require(ownerOf(tokenId) == msg.sender, "Solo il proprietario puo' rifiutare");
        require(draftIndex < pendingCertifications[tokenId].length, "Indice bozza non valido");
        CertificationDraft memory draft = pendingCertifications[tokenId][draftIndex];
        emit CertificationRejected(tokenId, draft.legalEntity, draft.certifier, reason);
        _removeDraft(tokenId, draftIndex);
    }

    function updateCVURI(uint256 tokenId, string memory newURI) external {
        require(ownerOf(tokenId) == msg.sender, "Solo il proprietario puo' aggiornare il CV");
        _setTokenURI(tokenId, newURI);
        emit CVUpdated(tokenId, newURI, msg.sender);
    }

    function getCertifications(uint256 tokenId) external view returns (Certification[] memory) {
        return certifications[tokenId];
    }

    function getPendingCertifications(uint256 tokenId) external view returns (CertificationDraft[] memory) {
        return pendingCertifications[tokenId];
    }

    function _removeDraft(uint256 tokenId, uint256 draftIndex) internal {
        uint256 last = pendingCertifications[tokenId].length - 1;
        if (draftIndex != last) {
            pendingCertifications[tokenId][draftIndex] = pendingCertifications[tokenId][last];
        }
        pendingCertifications[tokenId].pop();
    }
}

